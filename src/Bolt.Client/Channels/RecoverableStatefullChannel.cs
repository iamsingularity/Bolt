using System;
using System.Threading.Tasks;

using Bolt.Client.Helpers;

namespace Bolt.Client.Channels
{

    /// <summary>
    /// Recoverable Bolt statefull channel.
    /// </summary>
    /// <typeparam name="TContract">The strongly typed Bolt proxy usually generated by Bolt tool.</typeparam>
    public abstract class RecoverableStatefullChannel<TContract> : RecoverableChannel
        where TContract : ContractProxy
    {
        private readonly string _sessionHeaderName;
        private readonly AwaitableCriticalSection _syncRoot = new AwaitableCriticalSection();

        private ConnectionDescriptor _activeConnection;
        private string _sessionId;

        protected RecoverableStatefullChannel(Uri server, ClientConfiguration clientConfiguration)
            : base(new SingleServerProvider(server), clientConfiguration)
        {
            _sessionHeaderName = clientConfiguration.Options.SessionHeader;
        }

        protected RecoverableStatefullChannel(IServerProvider serverProvider, ClientConfiguration clientConfiguration)
            : base(serverProvider, clientConfiguration)
        {
            _sessionHeaderName = clientConfiguration.Options.SessionHeader;
        }

        protected RecoverableStatefullChannel(RecoverableStatefullChannel<TContract> proxy)
            : base(proxy)
        {
            _sessionHeaderName = proxy._sessionHeaderName;
        }

        protected RecoverableStatefullChannel(
            IServerProvider serverProvider,
            string sessionHeaderName,
            IRequestHandler requestHandler,
            IEndpointProvider endpointProvider)
            : base(serverProvider, requestHandler, endpointProvider)
        {
            _sessionHeaderName = sessionHeaderName;
        }

        public string SessionId
        {
            get { return _sessionId; }
        }

        public virtual bool IsRecoverable
        {
            get { return true; }
        }

        public override async Task OpenAsync()
        {
            await EnsureConnectionAsync();
            IsOpened = true;
        }

        public override async Task CloseAsync()
        {
            if (IsClosed)
            {
                return;
            }

            using (_syncRoot.Enter())
            {
                if (IsClosed)
                {
                    return;
                }

                try
                {
                    if (_activeConnection != null)
                    {
                        string sessionId = _sessionId;

                        DelegatedChannel channel = new DelegatedChannel(
                            _activeConnection.Server,
                            RequestHandler,
                            EndpointProvider,
                            (c) =>
                            {
                                BeforeSending(c);
                                WriteSessionHeader(c, sessionId);
                            },
                            AfterReceived);

                        TContract contract = CreateContract(channel);
                        await OnProxyClosingAsync(contract);
                    }
                }
                finally
                {
                    _activeConnection = null;
                    _sessionId = null;
                    base.Close();
                }
            }
        }

        protected abstract Task OnProxyClosingAsync(TContract contract);

        protected abstract Task OnProxyOpeningAsync(TContract contract);

        protected override bool HandleError(ClientActionContext context, Exception error)
        {
            if (error is BoltServerException && (error as BoltServerException).Error == ServerErrorCode.SessionNotFound)
            {
                if (!IsRecoverable)
                {
                    return false;
                }

                CloseConnection();
                return true;
            }

            return base.HandleError(context, error);
        }

        protected void CloseConnection()
        {
            using (_syncRoot.Enter())
            {
                bool exist = _activeConnection != null;
                _activeConnection = null;
                _sessionId = null;

                if (exist)
                {
                    OnConnectionClosed();
                }
            }
        }

        protected override void BeforeSending(ClientActionContext context)
        {
            WriteSessionHeader(context, _sessionId);
            base.BeforeSending(context);
        }

        protected override async Task<ConnectionDescriptor> GetConnectionAsync()
        {
            EnsureNotClosed();
            ConnectionDescriptor uri = await EnsureConnectionAsync();
            IsOpened = true;
            return uri;
        }

        protected virtual void OnConnectionOpened(ConnectionDescriptor activeConnection, string sessionId)
        {
        }

        protected virtual void OnConnectionClosed()
        {
        }

        protected TContract CreateContract(IChannel channel)
        {
            return (TContract)Activator.CreateInstance(typeof(TContract), channel);
        }

        protected TContract CreateContract(Uri server)
        {
            return CreateContract(new DelegatedChannel(server, RequestHandler, EndpointProvider, BeforeSending, AfterReceived));
        }

        private async Task<ConnectionDescriptor> EnsureConnectionAsync()
        {
            EnsureNotClosed();

            if (_activeConnection != null)
            {
                return _activeConnection;
            }

            using (await _syncRoot.EnterAsync())
            {
                if (_activeConnection != null)
                {
                    return _activeConnection;
                }

                var connection = ServerProvider.GetServer();
                string sessionId = null;
                ActionDescriptor action = null;

                TContract contract =
                    CreateContract(
                        new DelegatedChannel(
                            connection.Server,
                            RequestHandler,
                            EndpointProvider,
                            (c) =>
                            {
                                WriteSessionHeader(c, sessionId);
                                BeforeSending(c);
                            },
                            (ctxt) =>
                            {
                                if (sessionId == null)
                                {
                                    action = ctxt.Action;
                                    sessionId = ctxt.Response.Headers.GetHeaderValue(_sessionHeaderName);

                                }
                            }));

                Exception error = null;

                try
                {
                    await OnProxyOpeningAsync(contract);
                }
                catch (Exception e)
                {
                    error = e;
                    if (sessionId == null)
                    {
                        throw;
                    }
                }

                if (error != null)
                {
                    try
                    {
                        await OnProxyClosingAsync(contract);
                    }
                    catch (Exception)
                    {
                        // OK, we tried to close pending proxy
                    }

                    throw error;
                }

                if (sessionId == null)
                {
                    throw new BoltServerException(ServerErrorCode.SessionIdNotReceived, action, connection.ToString());
                }

                OnConnectionOpened(_activeConnection, _sessionId);

                _activeConnection = connection;
                _sessionId = sessionId;
                return connection;
            }
        }

        private void WriteSessionHeader(ClientActionContext context, string sessionId)
        {
            if (!string.IsNullOrEmpty(sessionId))
            {
                context.Request.Headers.Add(_sessionHeaderName, sessionId);
            }
        }
    }
}